# Cache Aside Pattern 旁路缓存策略    
## 读策略
* 从缓存中读取数据；
* 如果缓存命中则直接返回数据；
* 如果缓存不命中则从数据库查询数据；
* 查询到数据后将数据写入缓存并返回。
## 写策略
* 更新数据库中的记录；
* 删除缓存记录。  

旁路缓存策略当写入频繁时缓存中的数据会被频繁清理，对缓存的命中率有一定影响，可以考虑两种解决方法：
* 在更新数据时也更新缓存，在更新缓存前加一个分布式锁，在同一时间只允许一个线程更新缓存。对于写入的性能有一定影响。
* 更新数据时更新缓存，给缓存加一个短的过期时间，即使出现缓存不一致的情况，缓存的数据会很快过期，对业务影响一定程度上可接受。

# Read/Write Through （读写/写穿）策略
## Write Through策略
先查询要写入的数据在缓存中是否已存在，如果已存在则更新缓存中的数据，并且由缓存组件同步更新到数据库，如果缓存中数据不存在，则Write Miss写失效，再直接同步更新数据库。
## Read Through
先查询缓存中数据是否存在，如果存在则直接返回，如果不存在则由缓存组件负责从数据库同步加载数据。  

开发中相比旁路缓存策略少见，因为经常使用的分布式缓存组件，无论是memcached还是redis都不提供写入数据库，或自动加载数据库数据的功能。使用本地缓存可以考虑使用此策略。

# Write Behind Pattern/Write Back (异步缓存写入)
Write Back相较于Write Through而言是一种异步回写策略。异步写可以减少与物理磁盘存储的交互，可以进行合并写等优化。适用于读少写多场景，Linux系统的页缓存和Mysql Innodb引擎的Cache Pool实际就是使用WriteBack策略。


# 缓存高可用方案
## 客户端方案
客户端方案就是再客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。
* 写入数据时，需要把被写入缓存的数据分散到多个节点中，即进行数据分片；
* 读数据时，可以利用多组的缓存来做容错，提升缓存系统可用性。关于读数据可以使用主从和多副本。
### 缓存数据如何分片
单一的缓存节点收到机器内存、网卡带宽和单节点请求量的限制，不能承担比较高的并发，因此考虑将数据分片，依照分片算法将数据打散到多个不同的节点上，每个节点上存储部分数据。这样在某个节点故障的情况下，其他节点也可以提供服务，保证一定的可用性。（用一致性hash算法可以很好的解决增加和删减节点时，命中率下降的问题，但节点数过多也可能会增加出问题的概率，一般推荐4到6个节点）
* 缓存节点在圆环上分布不平静会造成部分缓存节点压力较大；当某个节点故障时这个节点所要承受的所有访问都会被顺移到另一个节点上，会对后面这个节点造成压力。（如一个有三个节点A、B、C承担整体的访问，每个节点的访问量平均，A故障后B将承担双倍的压力，当B承担不了流量Crash后，C将因为成功原先三倍的流量而Crash，这就会造成整体缓存系统的雪崩。为此可以在一致性hash算法中引入虚拟节点的概念，它将一个缓存节点计算多个hash值分散到圆环的不同位置，实现数据的平均，当某一个节点故障退出时原先承担的key将以更加平均的方式分配到其他节点上，从而避免雪崩。）
* 一致性hash算法的脏数据问题。（如在集群中有两个节点A和B，客户端初始写入一个key为K值为3的缓存数据到cache中。此时若更新key值为4，但缓存A与客户端连接出现问题，那么这次写入请求会写入到cache B中。之后缓存A和客户端连接恢复，当客户端获取k值时就会获取到cache A中的脏数据3.为此在使用一致性hash算法时一定要设置缓存的过期时间。）
### 缓存数据库的主从，如memcache、redis
### 缓存服务器的一主多从
## 中间代理层方案
所有缓存的读写请求都是经过代理层完成的。代理层是无状态的，主要负责读写请求的路由功能，并且在其中内置了一些高可用的逻辑，不同的开源中间代理层方案中使用的高可用策略各有不同。在Twemproxy中，Proxy保证在某一个redis节点挂掉之后会把它从集群中移除，后续请求将由其他节点完成。
## 服务端方案
redis在2.4版本中提出了redis Sentinel模式来解决主从Redis部署时的高可用问题，它可以在主节点挂了以后自动将从节点提升为主节点，保证整体集群的可用性。  
redis sentinel也是集群部署的，这样可以避免sentinel节点挂掉造成无法自动故障恢复的问题，每一个sentinel节点都是无状态的。在sentinel中会配置master地址，sentinel会时刻监控master状态。当发现master在配置的时间间隔内无法响应，则认为master挂掉，sentinel会从从节点选取一个提升为主节点，并且把所有其他从节点作为新主的从节点。sentinel集群在内部仲裁的时候，会根据配置的值来决定当有几个sentinel节点认为主挂点可以做主从切换的操作，也就是集群内部需要对缓存节点的状态达成一致。  
redis sentinel不属于代理层模式，因为对于缓存的写入和读取请求不会经过sentinel节点。sentinel节点在架构和主从是平级的，是作为管理正存在的，所以可以认为是在服务端提供的一种高可用方案。
