## 缓存中的结构

### sorted set

#### skiplist
跳跃表是一种有序的数据结构，它通过在每个节点中维护多个指向其他节点的指针，从而达到快速访问队尾的目的。跳跃表的效率可以和平衡树媲美，最关键在于其实现相对于平衡树来说，代码的实现上简单。  
跳跃表在redis中使用，一是实现有序集合键，二是集群节点中用作内部数据结构。  
##### level定义
跳跃表的level层级完全是随机的，一般层级越多，访问节点的速度越快。
##### 插入
层级随机，每个层级最末端节点指向都是null，表示该层级到达末尾，可以跳向下一级。新插入一个节点不会影响其他节点的层数。如一个节点随机的层数是3，那么就将它链入到第1层到第3层这三层链表中。
![avatar](./跳跃表插入.png)
##### 查询
跳跃表的查询是从顶层往下找，那么会先从第一层顶层开始找，通过循环比较，如果顶层节点的下一个节点为空说明到达末尾，跳到第2层，继续遍历，直到找到对应节点。  
在跳到下一层遍历时，不是重新遍历，而是从当前这个节点继续往下找下一个节点。
![avatar](./跳跃表查找.png)

实际应用中skiplist每个节点应该包含key和value两部分。实际上列表中是按照key进行排序的，查找过程也是根据key在比较。平均时间复杂的O(log n)。
##### skiplist和平衡树、哈希表比较
* skiplist和各种平衡树（如红黑树等）的元素是有序排列的，而哈希表不是有序的。因此在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找指的是查找那些大小在指定的两个值之间的所有节点。
* 在做范围查找的时候，平衡树比skiplist操作复杂。在平衡树上，找到指定范围的小值之后，还需要以中序遍历的顺序继续查找其他不超过大值的节点。如果不对平衡树进行一定改造，其中的中序遍历并不容易实现。而skiplist进行范围查找比较简单，只需要在找到小值之后，对第1层链表进行若干步遍历就可实现。
* 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist只需修改相邻节点的指针。
* 内存占用上来看，skiplist比平衡树更灵活。平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
* 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
