## 缓存穿透
缓存穿透其实是指从缓存中没有查到数据，而不得不从后端系统（如数据库）中查询的情况。  
例如读取一个用户表中未注册的用户，按照旁路缓存策略，会先读缓存，再穿透读数据库。由于用户并不存在，所以缓存和数据库中都没有查询到数据，因此也就不会向缓存中回种数据，这样当再次请求这种用户数据时还是会再次穿透到数据库。  
解决缓存穿透两种方案：回种空值和使用布隆过滤器。
### 回种空值
回种空值虽能够阻挡大量穿透的请求，但如果有大量获取未注册用户信息的请求，缓存内就会有大量的空值缓存，也就会浪费缓存的存储空间，如果缓存空间被占满了，还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降。
### 布隆过滤器
布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个hash算法组成。基本思路是：把集合中的每一个值按照提供的hash算法算出对应的hash值，然后将hash值对数组长度取模后得到需要计入数组的索引值，并且将数组这个位置的值从0改为1。在判断一个元素是否存在于这个集合中时，只需要将这个元素按照相同的算法计算出索引值，如果这个位置的值为1就认为这个元素在集合中，否则则认为不在集合中。  
对于布隆过滤器而言，本质是一个位数组：位数组就是数组的每个元素都只占用1bit，并且每个元素只能是0或1。  
长数组加多个hash算法  

--- 
以上面用户信息为例，首先初始化一个很大的数组，如长度为20亿的数组，然后选择一个hash算法，将目前现有的所有用户的ID计算出hash值并且映射到大数组中，映射位置的值设为1，其他值设为0。  
新注册用户除了需要写入到数据库中之外，也需要依照同样的算法更新布隆过滤器的数组中相应位置的值。当需要查询某一个用户的信息时，首先查询这个ID在布隆过滤器中是否存在，如果不存在直接返回空值不再需要查询数据库和缓存，以此极大地减少异常查询带来的缓存穿透。  
布隆过滤器拥有极高的性能，无论是写入操作还是读取操作，时间复杂度都是O(1)，是常量值。在空间上，相对于其他数据结构也有很大优势，如20亿的数组需要2000000000/8/1024/1024 = 238M空间，而如果使用数组来存储，假设每个用户ID占用4个字节，则存储20亿需要2000000000 * 4 / 1024 / 1024 = 7600M空间。
#### 缺点
在判断元素是否在集合中时有一定错误几率（哈希碰撞），可能会把不是集合中的元素判断为处在集合中；  
不支持删除元素
#### 布隆过滤器为什么适合解决缓存穿透
当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中，它一定不在集合中。  
布隆过滤器虽然存在误判的情况，但是还是会减少缓存穿透的情况发生，只是需要尽量减少误判几率，使得布隆过滤器判断正确几率更高，对缓存穿透也更少。
#### 减少误判
使用多个hash算法为元素计算出多个hash值，只有所有hash值对应的数组中的值都为1时，才会认为这个元素在集合中。  

---
布隆过滤器不支持删除元素的缺陷也和hash碰撞有关。假如两个元素A和B都是集合中的元素，它们有相同的hash值，它们就会映射到数组的同一个位置，这时如果删除了A，数组中对应位置的值也从1变成0，那么在判断B的时候发现值是0，也会认为B是不在集合中的元素，就会得到错误的结论。  
如何解决：让数组中不再只有0和1两个值，而是存储一个计数。比如如果A和B同时命中了一个索引，那么这个位置的值就是2，如果A被删除了就把这个值从2改为1。此方案中的数组不再存储bit位，而是存储数值，会增加空间的消耗。  
#### 补充
缓存穿透后的并发方案
1. 代码中，控制在某一个热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而是直接返回；
2. 通过设置分布式锁，只有获取到锁的请求才能够穿透到数据库。分布式锁的方式也比较简单，比方说ID为1的用户是一个热点用户，当他的用户信息缓存失效后，我们需要从数据库中重新加载数据时，先向Memcached中写入一个Key为"lock.1"的缓存项，然后去数据库里面加载数据，当数据加载完成后再把这个Key删掉。这时，如果另外一个线程也要请求这个用户的数据，它发现缓存中有Key为“lock.1”的缓存，就认为目前已经有线程在加载数据库中的值到缓存中了，它就可以重新去缓存中查询数据，不再穿透数据库了。

### 布谷鸟过滤器
* 支持动态的新增和删除元素；
* 提供了比传统布隆过滤器更高的查找性能，即使在接近满的情况下（比如空间利用率达到95%时候）；
* 比诸如商过滤器（quotient filter另一种过滤器）之类的替代方案更容易实现；
* 如果要求错误率小于3%，那么在许多实际应用中比布隆过滤器占用的空间更小。  

布谷鸟hash，存储的是插入元素的原始值，比如x，x会经过两个hash函数，如果记数组的长度位L，则：p1 = hash1(x) % L；p2 = hash2(x) % L。  
而布谷鸟过滤器计算位置：h1(x) = hash(x)，h2(x) = h1(x) ⊕ hash(x’s fingerprint)。在计算h2（位置2）时，对x的fingerprint进行了一个hash计算。在位置的计算上，算法中的异或运算确保了一个重要的性质：位置h2可以通过位置h1和h1存储的”指纹“计算得出。也就是只要知道了一个元素的位置（h1）和该位置里面存储的指纹信息，那么就可以知道该指纹的备用信息（h2）。因为使用的异或运算，所以这两个位置具有对偶性。只要保证hash(x’s fingerprint) !=0，那么就可以确保h2!=h1，也就可以确保，不会出现自己踢出自己的死循环问题。  
为什么要对”指纹“进行一个hash计算之后再进行异或运算？反证：如果不进行hash计算，假设”指纹“的长度是8bit，那么其对偶位置算出来，距离当前位置最远也才256。因为如果指纹长度是8bit，那么异或操作只会改变当前位置h1(x)的低8位，高位不会改变。就算把低8位全部改了，算出的位置仍旧是最远256位。  
因此，对”指纹“进行hash处理可以确保被踢出去的元素，可以重新定位到哈希表中完全不同的存储桶中，从而减少哈希冲突并提高表利用率。  
布谷鸟过滤器并没有对数组长度进行取模，而是强制数组的长度必须是2的指数倍，以此进行异或运算时可以保证计算出来的下标一定是落在数组中的。  
”指纹“实际上是插入的元素进行一个hash计算，而hash计算的产物就是几个bit位。布谷鸟过滤器里面存储的就是元素的”指纹“。查询数据时就是看对应的位置上有没有对应的”指纹“信息。删除数据的时候，也只是抹掉该位置上的”指纹“而已。