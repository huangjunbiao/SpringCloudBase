## JVM
### 内存区域
线程私有：程序计数器、虚拟机栈、本地方法栈。  
线程共享：堆、方法区、直接内存。
#### 程序计数器
程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。  
为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各线程之间互不影响，独立存储。
> 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，线程结束而死亡。
#### 虚拟机栈
Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。  
Java内存可以粗糙的分为堆内存(heap)和栈内存(stack)，其中栈就是虚拟机栈，或者说是虚拟机栈中局部变量表。（实际上，Java 虚拟机栈是由⼀个个栈帧组成，⽽每个栈帧中都拥有：局部变量表、操作数栈、动态链接、⽅法出⼝信息。）  
局部变量表主要存放了编译器可知的数据类型、对象引用。  
Java虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError 。
* StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求的栈深度超过当前Java虚拟机最大深度时，会抛出此错误。
* OutOfMemoryError：若Java虚拟机堆中没有可用内存，并且垃圾回收器无法提供更多内存，抛出此错误。
##### 本地方法栈
本地方法栈为虚拟机使用到的本地方法服务。在hotspot中和Java虚拟机栈合二为一。
#### 堆
Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存唯一目的是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。  
随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术导致一些微妙的变化，不再是所有对象都在堆上分配了。jdk1.7默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配。  
堆中最容易出现OutOfMemoryError错误：OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执⾏垃圾回收并且只能回收很少的堆空间时，就会发⽣此错误；java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不⾜以存放新创建的对象, 就会引发 java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存⽆关，和你配置的内存⼤⼩有关！)
#### 方法区
方法区也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
jdk1.8之后方法区被元空间取代。元空间使用直接内存。
> 元空间使用直接内存受本机可用内存限制，出现溢出的几率更小，而且能加载更多的类。
#### 运行时常量池
运行时常量池是方法区的一部分，Class文件除了有类版本、字段、方法、接口等描述信息还有常量池表（用于存放编译期生成的各种字面量和符号引用）。
#### 直接内存
直接内存不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用，也可能出现OutOfMemoryError错误。
### Java对象创建过程
类加载检查->分配内存->初始化零值->设置对象头->执行init方法
#### 类加载检查
虚拟机遇到一条new指令首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那么必须先执行响应的类加载过程。
#### 分配内存
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块大小确定的内存从Java堆中划分出来。分配的方式有指针碰撞和空闲列表，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又有所采用的垃圾收集器是否带有压缩整理功能决定。
* 指针碰撞：适用堆内存规整的情况，将使用过的内存与未使用的内存分界，中间有一个分界值指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
* 空闲列表：堆内存不规整的情况下，虚拟机会维护一个列表，列表中记录哪些内存块是可用的，在分配的时候找到一块足够大的内存块划分给对象实例，最后更新列表记录。  

创建对象，内存分配并发问题：
* CAS+失败重试：CAS是乐观锁的一种实现方式。所谓乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS加失败重试方案保证更新操作的原子性；
* TLAB：为每一个线程预先在Eden区分配一块内存，JVM在给线程中对象分配内存时首先在TLAB上分配，当对象大于TLAB剩余内存或已耗尽，再采用CAS方式分配。
#### 初始化零值
内存分配完后，虚拟机需要将分配到的内存空间都初始化为零值，这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
#### 设置对象头
初始化零值完成后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外根据虚拟机当前运行状态不同，如是否启用偏向锁等对象头会有不同的设置方式。
#### 执行init方法
以上工作完成后，从虚拟机角度看，新对象已经产生，但从Java程序来说，对象创建刚开始，<init>方法还没有执行，所有的字段都还是零。一般执行new指令之后i，会接着执行init方法，把对象按照程序的设计进行初始化。
### 对象访问定位方式
主流访问方式有使用句柄和直接指针
* 句柄：使用句柄的话，Java堆中将会划出一块内存作为句柄池，reference中存储的就是对象的句柄，而句柄包含了对象实例数据与类型数据各自的具体地址信息；
* 直接指针：使用直接指针访问，那么Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址。
> 使用句柄方法最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问最大的好处是速度快，节省了一次指针定位的时间开销。
### 主要进行GC的区域
部分收集（Partial GC）：
* 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
* 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需注意Major GC有时也用于指代整堆收集；
* 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集（Full GC）：收集整个堆和方法区
### 判断对象死亡，垃圾回收
* 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效，计数器就减1；任何时候计数器为0的对象就是不再被使用的；
* 可达性分析算法：通过一系列称为gc roots的对象作为起点。从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到gc roots没有任何引用链，则此对象是不可用的。

### java jmm volatile
volatile关键字是Java虚拟机提供的最轻量化的同步机制，它作为一个修饰符，用来修饰变量。它保证变量对所有线程可见性，禁止指令重排，但是不保证原子性。  
Java内存模型（jmm）：
* java虚拟机规范试图定义一种Java内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上都能达到一致的内存访问效果。
* 为了更好的执行性能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存打交道，也没有限制编译器进行调整代码顺序优化。所以Java内存模型会存在缓存一致性问题和指令重排序问题。
* Java内存模型规定所有的变量都是存在主内存中，每个线程都有自己的工作内存。这里的变量包括实例变量和静态变量，但是不包括局部变量，因为局部变量都是线程私有的。
* 线程的工作内存保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存。并且每个线程不能访问其他线程的工作内存。

volatile变量保证新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以volatile保证了多线程操作变量的可见性。  
指令重排序是指在程序执行过程中，为了提高性能，编译器和CPU可能会对指令进行重新排序。在Java中有一个先行发生原则(happens-before)：
* 程序次序规则：在一个线程内按照控制流顺序书写在前面的操作先行发生于书写在后面的操作；
* 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作；
* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
* 线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作；
* 线程终止规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join方法结束、isAlive方法的返回值检测到线程已经终止执行；
* 线程中断规则：对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
* 对象终结规则：一个对象的初始化完成先行发生于操作B，而操作B又先行发生于它的finalize方法的开始；
* 传递性：如果操作A先行发生于操作B，而操作B先行发生于操作C，则操作A也先行发生于操作C。

实际上volatile保证可见性和禁止指令重排序都跟内存屏障有关。有volatile修饰时，编译后会多出一个lock前缀指令，lock指令相当于一个内存屏障，保证以下几点：
* 重排序时不能把后面的指令重排序到内存屏障之前的位置；
* 将本处理器的缓存写入内存；
* 如果是写入动作，会导致其他处理器中对应的缓存无效。

内存屏障四大分类：（load代表读取指令，store代表写入指令）
* LoadLoad屏障：（Load1;LoadLoad;Load2），在load2要读取的数据被访问之前保证load1要读取的数据被读取完；
* StoreStore屏障：（Store1;StoreStore;Store2），在store2写入执行前，保证store1的写入操作对其他处理器可见；
* LoadStore屏障：（Load1;LoadStore;Store2），在store2写入前，保证load1读取的数据被读取完毕；
* StoreLoad屏障：（Store1;StoreLoad;Load2），在load2读取数据之前，保证store1的写入对所有处理器可见。

为了实现volatile的内存语义，Java内存模型采用以下保守策略：
* 在每个volatile写操作前插入一个storestore屏障；
* 在每个volatile的写操作后插入一个storeload屏障；
* 在每个volatile的读操作前插入一个loadload屏障；
* 在每个volatile的读操作之后插入一个loadstore屏障。