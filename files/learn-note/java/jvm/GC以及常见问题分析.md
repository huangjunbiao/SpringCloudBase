## GC基础
**GC：**
* Garbage Collection：垃圾收集技术，名词。
* Garbage Collector：垃圾收集器，名词。
* Garbage Collecting：垃圾收集动作，动词。  

**Mutator：** 生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。

**TLAB：** Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。

**Card Table：** 中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为 dirty，卡表的本质是用来解决跨代引用的问题。
### Card Table 卡表
HostSpot JVM为了解决老年代到新生代的引用问题，使用卡表和写屏障（Write Barrier）来进行标记并加快GC Roots的扫描。
#### 卡表结构
基于卡表的设计，通常将堆空间划分为一系列2次幂大小的卡页（card page）。卡表用于标记卡页的状态，每个卡表项对应一个卡页。
HotSpot JVM的卡页大小为512字节，卡表被实现为一个简单的字节数组，即卡表的每个标记项为1个字节。
当对一个对象引用进行写操作时（对象引用改变），写屏障逻辑将会标记对象所在的卡页为dirty。
首先计算对象引用所在卡页的卡表索引号，将地址右移9位，相当于用地址除以512（2的9次方）。
即假设卡表卡页的起始地址位0，那么卡表项0、1、2对应的卡页起始地址分别为0、512、1024。其次通过卡表索引号设置对应卡标识为dirty。
#### 问题
1.无条件写屏障带来的性能开销
> 每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，与YGC时扫描整个老年代相比较，这个开销就低得多了。
不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题。

2.高并发下虚共享带来的性能开销
> 在高并发情况下，频繁的写屏障很容易发生虚共享（false sharing），从而带来性能开销。
假设CPU缓存行大小为64字节，由于一个卡表项占1个字节，这意味着，64个卡表项将共享同一个缓存行。
HotSpot每个卡页为512字节，那么一个缓存行将对应64个卡页一共64*512=32KB。
如果不同线程对对象引用的更新操作，恰好位于同一个32KB区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。
一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为dirty。
这就是JDK 7中引入的解决方法，引入了一个新的JVM参数-XX:+UseCondCardMark，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。
与原来的实现相比，只是简单的增加了一个判断操作。虽然开启-XX:+UseCondCardMark之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现虚共享问题（false sharing）。
## 内存划分
GC主要工作在Heap区和MetaSpace区。
### 分配对象
Java 中对象地址操作主要使用 Unsafe 调用了 C 的 allocate 和 free 两个方法，分配方法有两种：
* 空闲链表（free list）：通过额外的存储记录空闲的地址，将随机 IO 变为顺序 IO，但带来了额外的空间消耗。
* 碰撞指针（bump  pointer）：通过一个指针作为分界点，需要分配内存时，仅需把指针往空闲的一端移动与对象大小相等的距离，分配效率较高，但使用场景有限。
### 收集对象
#### 识别垃圾
* 引用计数法（Reference Counting）：对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。
* 可达性分析，又称引用链法（Tracing GC）：从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。
> 引用计数法是可以处理循环引用问题的
#### 收集算法
自从有自动内存管理出现之时就有的一些收集算法，不同的收集器也是在不同场景下进行组合。
* Mark-Sweep（标记-清除）：回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。
* Mark-Compact （标记-整理）：这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等。
* Copying（复制）：将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。有递归（Robert R. Fenichel 和 Jerome C. Yochelson提出）和迭代（Cheney 提出）算法，以及解决了前两者递归栈、缓存行等问题的近似优先搜索算法。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高。
#### 收集器
目前在 Hotspot VM 中主要有分代收集和分区收集两大类，在 JDK11 后提供了一个不执行任何垃圾回收动作的回收器 Epsilon（A No-Op Garbage Collector）用作性能分析。
##### 分代收集器
* ParNew：一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 -XX:ParallelGCThreads 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。（新生代采用复制，老年代采用标记-整理）
* CMS：以获取最短回收停顿时间为目标，采用“标记-清除”算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B/S 系统的服务器端上，JDK9 被标记弃用，JDK14 被删除，详情可见https://openjdk.java.net/jeps/363。
###### CMS收集器
是Hotspot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程和用户线程同时工作。采用标记-清除算法实现。
* 初始标记：暂停所有其他线程，并记录下直接与root相连的对象，速度很快；
* 并发标记：同时开启GC和用户线程，用一个闭包记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。
* 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段时间长，远低于并发标记阶段时间。
* 并发清除：开启用户线程，同时GC线程开始对未标记的区域进行清扫。
> 主要优点是并发收集、低停顿；但是对CPU资源敏感、无法处理浮动垃圾、使用的回收算法会产生大量空间碎片。
##### 分区收集器
* G1：一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。
* ZGC：JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。
* Shenandoah：由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table 来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近，下图为与 CMS 和 G1 等收集器的 benchmark。
###### G1收集器
面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求同时具备高吞吐量。
* 并行和并发：充分利用CPU多核环境优势缩短STW时间，通过并发的方式让Java程序继续执行。
* 分代收集：可以不需要与其他收集器配合就能独立管理整个堆，但仍然保留了分代的概念。
* 空间整合：整体来看基于标记整理算法，局部来看是基于复制算法；
* 可预测的停顿：建立可预测的停顿时间模型，让使用者明确指定在一个长度为m毫秒的时间片段内。