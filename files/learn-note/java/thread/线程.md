### AQS
AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS使用CLH队列锁实现，即将暂时获取不到锁的线程加入队列中。
> CLH队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH队列锁的一个节点来实现锁分配。  
> AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队。AQS使用CAS对该同步状态进行原子操作从而修改其值。
#### AQS对资源的共享方式
* Exclusive（独占）：只有一个线程能执行，如ReentrantLock，又可分为公平锁和非公平锁。[公平锁：按照线程在队列中的排队顺序先到者先拿到锁；非公平锁：当线程要获取锁时无视队列的顺序抢锁。]
* share（共享）：多个线程可以同时执行（CountDownLatch 、 Semaphore 、 CountDownLatch 、 CyclicBarrier 、 ReadWriteLock）

ReentrantReadWriteLock可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。  
不同的自定义同步器争用共享资源的方方式不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于线程等待队列的维护，AQS在顶层已实现。
#### AQS底层使用模板方法模式
同步器的设计是基于模板方法模式的，如果需要自定义同步器一般方式：  
1. 使用者继承AbstractQueuedSynchronizer并重写指定方法；
2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法。
#### AQS组件总结
* Semaphore（信号量）-允许多个线程同时访问：synchronized 和 ReentrantLock都是一次允许一个线程访问某个资源，Semaphore可以指定多个线程同时访问；
* CountDownLatch（倒计时器）：是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束再执行。
* CyclicBarrier（循环栅栏）：CyclicBarrier 和 CountDownLatch类似，也可以实现线程间的技术等待，它是可循环使用的屏障。它让一组线程达到一个屏障时被阻塞，直到最后一个线程到达屏障时，才会开启，所有被屏障拦截的线程才会继续干活。每个线程调用await()方法告诉CyclicBarrier已达屏障，然后当前线程被阻塞。



### 多线程
线程是比进程更小的执行单位，一个进程可以在其执行过程中产生多个线程。多个线程共享进程的堆和方法去资源，每个线程有自己的程序计数器、虚拟机栈、本地方法栈。
#### 程序计数器、虚拟机栈、本地方法栈为什么私有
程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。  
虚拟机栈：每个Java方法执行时同时创建一个栈帧存放局部变量表、操作数栈、常量池引用等信息；本地方法栈：为本地方法服务。线程私有可以保证线程中的局部变量不被别的线程访问到。
#### sleep()方法和wait()方法
* 两者最主要区别：sleep没有释放锁，wait释放了锁；
* 两者都可以暂停线程的执行；
* wait通常被用于线程间交互/通信，sleep被用于暂停执行；
* wait方法被调用后线程不会自动苏醒，需要其他线程调用上一个对象的notify或notifyAll；sleep执行完后线程会自动苏醒，或者使用wait超时后线程自动苏醒。
#### 实现runnable接口和callable接口区别
runnable接口不会返回结果或抛出检查异常，但是callable接口可以。如果任务不需要返回结果或抛出异常使用runnable。
#### 执行execute方法和submit方法区别
* execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
* submit方法用于提交需要返回值的任务。线程池会返回一个Future类型对象，通过这个Future对象可以判断任务是否执行成功，并且通过其get方法来获取返回值，get方法会阻塞当前线程直到任务完成。


### 线程池
阿里规范中强制线程池不允许使用Executor创建，而是通过ThreadPoolExecutor方式。这样处理可以更加明确线程池的运行规则，规避资源耗尽风险。
> FixedThreadPool 和 SingleThreadExecutor允许请求的队列长度为Integer.MAX_VALUE，可能堆积大量的请求，从而导致OOM；CachedThreadPool 和 ScheduledThreadPool允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。

ThreadPoolExecutor
* 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗；
* 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能执行；
* 提高线程的管理性，线程池可以对线程进行统一分配、调优和监控。
#### 线程池实现
1. 构造方法 ThreadPoolExecutor
2. 通过 Executor 框架的⼯具类 Executors 来实现
* FixedThreadPool：返回一个固定线程数量的线程池。该线程池中的线程数量始终不变，当有一个新任务提交时，线程池若有空闲线程则立即执行，若没有，则新任务会暂存任务队列中，待有线程空闲时，便处理任务队列中的任务；
* SingleThreadExecutor：返回一个只有一个线程的线程池。若多于一个任务被提交到该线程池，任务会被暂存到队列中，等线程空闲时，按先入先出顺序执行队列中任务；
* CachedThreadPool：返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后将返回线程池进行复用。
#### 核心参数
* corePoolSize：线程池核心线程数最大值（最⼩可以同时运⾏的线程数量）；
* maximumPoolSize：线程池最大线程数大小（当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数量变为最⼤线程数）；
* keepAliveTime：线程池中非核心线程空闲的存活时间；
* unit：线程空闲存活时间；
* workQueue：存放任务的阻塞队列（当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到的话，新任务就会被存放在队列中）；
* threadFactory：用于设置创建线程的工厂，可以给创建线程设置名称；
* handler：线程池的饱和策略事件。
#### 四种饱和拒绝策略
* AbortPolicy：默认的，抛出异常；
* DiscardPolicy：直接丢弃任务；
* DiscardOldestPolicy：丢弃队列里最老的任务，将当前这个任务继续提交给线程池；
* CallerRunsPolicy：交给线程池调用所在线程处理（这种策略会降低新任务提交速度，影响程序整体性能。并且该策略喜欢增加队列容量，需要承受延迟并且不丢弃任何一个任务）。
#### 线程池原理
* 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务；
* 如果线程池核心线程数已满，即线程数等于corePoolSize，一个新提交的任务会被放进任务队列workQueue中，排队等待执行；
* 当线程池里面存活的线程数已经等于corePoolSize并且队列已满，判断线程数是否达到maximumPoolSize，如果没达到，创建一个非核心线程执行提交的任务；
* 如果当前的线程数达到maximumPoolSize，还有新的任务过来，则按照策略进行处理。