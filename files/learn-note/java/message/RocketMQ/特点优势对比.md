# RocketMQ  
## 对比Kafka
### 数据可靠性
* RocketMQ支持异步实时刷盘，同步刷盘，同步复制、异步复制；  
* Kafka使用异步刷盘方式，异步复制/同步复制；  
> RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统crash导致数据丢失。
> Kafka同步Replication理论上性能低于RocketMQ的同步Replication，原因是Kafka的数据以分区为单位组织，意味着一个Kafka实例上会有几百个数据分区，RocketMQ一个实例上只有一个数据分区，RocketMQ可以充分利用IO组commit机制，批量传输数据，配置同步Replication与异步Replication相比，性能损耗约20%~30%。
### 性能对比 
* Kafka单机写入TPS约在百万条/秒，消息大小10个字节；
* RocketMQ单机写入TPS单实例约在7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节。
> Kafka主要是由于Producer端将多个小消息合并，批量发向Broker。  
### 单机支持的队列数
* Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长。Kafka分区数无法过多的问题。
* rocketMQ单机支持最高5万个队列，负载不会发生明显变化。
### 队列多有什么好处
* 单机可以创建更多的话题，因为每个主题都是由一批队列组成；
* 消费者的集群规模和队列数成正比，队列越多，消费类集群可以越大。
> RocketMQ支持的队列数远高于kafka支持的partition数，这样RocketMQ可以支持更多的consumer集群。
### 消息投递实时性
* Kafka使用短轮询方式，实时性取决于轮询间隔时间，0.8以后版本支持长轮询；
* rocketMQ使用长轮询，同push方式实时性一致，消息的投递延时通常在几个毫秒。
> kafka与RocketMQ都支持长轮询，消息投递的延迟在几毫秒内。
### 消费失败重试
* Kafka消费失败不支持重试；
* rocketMQ消费失败支持定时重试，每次重试将时间顺延。
> 例如充值类应用，当前时刻调用运营商网关，充值失败，可能是对方压力过多，稍后再调用就会成功，如支付宝到银行卡扣款也是类似需求。此处的重试需要可靠的重试，即失败重试的消息不因为consumer宕机导致丢失。
### 严格的消息顺序
* Kafka支持消息顺序，但是一台代理宕机后，会产生消息乱序；
* rocketMQ支持严格的消息顺序，在顺序消息场景下，一台broker宕机后，发送消息会失败，但是不会乱序。如MySQL的二进制日志分发需要严格的消息顺序。  
> kafka不保证消息有序，RocketMQ可保证严格的消息顺序，即使单台Broker宕机，仅会造成消息发送失败，但不会消息乱序。
### 定时消息
* Kafka不支持定时消息；
* rocketMQ支持两类定时消息；
* 开源版本rocketMQ仅支持定时级别，定时级用户可定制；
* 阿里云MQ指定的毫秒级别的。
### 分布式事务消息
* Kafka不支持分布式事务消息；
* 阿里云MQ支持分布式事务消息，部分开源版本也支持（3.0.8之前以及4.3.0之后）。
### 消息查询
* Kafka不支持消息查询；
* rocketMQ支持根据消息标识查询，也支持消息内容查询（发送消息指定一个消息密钥）。
> 消息查询对于定位消息丢失等问题很有帮助。
### 消息回溯
* Kafka理论上可以按照offset来回溯消息；
* rocketMQ支持按照时间来回溯消息，精度毫秒，如从一天之前的某时某分某秒开始重新消费消息。
### 消息并行度
* Kafka消费并行度依赖topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开始1个线程），或者1台机器消费（10个线程并行消费），即消费并行度和分区数一致；
* rocketMQ消费并行度，①：顺序消费并行度与Kafka一致；②：乱序方式并行度取决于consumer线程数，如topic配置10个队列，10台机器消费，每台机器100个线程，则并行度为1000.
> kafka的消费并行度等于partition数；RocketMQ的消费并行度等于消费的线程数，不受队列数限制。
### 消息轨迹
* Kafka不支持消息轨迹；
* 阿里云MQ支持消息轨迹。

## ActiveMQ
Apache出品，支持多种语言和协议编写客户端。点对点模式、发布订阅模式，消息确认机制。单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠丢数据概率低。维护较少。
## RabbitMQ
是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统。erlang语言实现，高并发性。吞吐量万级，功能比较完备、健壮、稳定、易用、跨平台。商业版收费。
### 组件核心
Connection(连接)、Channel(信道)、Exchange(交换机)、Queue(队列)、VirtualHost(虚拟主机)
* Connection：每个生产者和消费者通过RabbitMQ发送与消费消息，首先要与其建立连接，即与broker之间的TCP连接。
* Channel：连接内部建立的虚拟逻辑连接，大部分操作如声明、发布、消费都是使用channel完成的。节省开销。
* VirtualHost：类似namespace概念，一个broker有多个VHost，每个Virtual host都有一套自己的Exchange和Queue，同一个Virtual host中的Exchange和Queue不能重名，不同的Virtual host中的Exchange和Queue名字可以一样，以此实现不同用户之间相互隔离的效果。
* Queue：存放消息的队列，
* Exchange：message到达broker的第一站，从生产者里接收消息，并根据交换类型分发规则分发到相应队列。direct、fanout、topic、headers
* RoutingKey：生产者将消息发到交换机时携带一个key来指定路由规则。
* BindingKey：在绑定交换机和队列时，指定一个key，生产者携带的routingKey和bindingKey对比，一致就将消息分发到这个队列。
#### 交换机类型
* direct：直接交换机，精确匹配routingKey，只有完全匹配消息才会转发。
* fanout：扇出交换机，即广播类型，消息发送至所有绑定的队列。
* topic：主题交换机，根据通配符对routingKey进行匹配，满足某个通配符条件就会被路由到对应队列。
* header：通过Arguments绑定，指定一组键值对，header为键，根据请求消息中携带的header进行路由。
### 工作模式
* simple：简单模式，一个消费者消费一个生产者生产的消息。
* work queues：工作模式，一个生产者生产消息，多个消费者消费消息，但一条消息只能被消费一次。
* Publish/Subscribe：发布订阅模式，生产者首先投递消息到交换机，订阅了这个交换机的队列会收到消息。
* routing：路由模式，生产者生产消息投递到direct交换机中，扇出交换机会根据消息携带的routing Key匹配相应的队列。
* topic：主题模式，根据主题模糊匹配，合适规则的路由投递给消费者。
### 消息稳定性
* 消息持久化：队列 交换机 发送持久化；
* ACK确认机制：消费完通知服务端；
* 设置集群镜像模式：镜像队列，多节点；
* 消息补偿机制：日志记录是否发送消费成功，失败的进行补偿。
