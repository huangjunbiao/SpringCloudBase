# RocketMQ  
## 对比Kafka
### 数据可靠性
* RocketMQ支持异步实时刷盘，同步刷盘，同步复制、异步复制；  
* Kafka使用异步刷盘方式，异步复制/同步复制；  
> RocketMQ的同步刷盘在单机可靠性上比Kafka更高，不会因为操作系统crash导致数据丢失。
> Kafka同步Replication理论上性能低于RocketMQ的同步Replication，原因是Kafka的数据以分区为单位组织，意味着一个Kafka实例上会有几百个数据分区，RocketMQ一个实例上只有一个数据分区，RocketMQ可以充分利用IO组commit机制，批量传输数据，配置同步Replication与异步Replication相比，性能损耗约20%~30%。
### 性能对比 
* Kafka单机写入TPS约在百万条/秒，消息大小10个字节；
* RocketMQ单机写入TPS单实例约在7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节。
> Kafka主要是由于Producer端将多个小消息合并，批量发向Broker。  
### 单机支持的队列数
* Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长。Kafka分区数无法过多的问题。
* rocketMQ单机支持最高5万个队列，负载不会发生明显变化。
### 队列多有什么好处
* 单机可以创建更多的话题，因为每个主题都是由一批队列组成；
* 消费者的集群规模和队列数成正比，队列越多，消费类集群可以越大。
### 消息投递实时性
* Kafka使用短轮询方式，实时性取决于轮询间隔时间，0.8以后版本支持长轮询；
* rocketMQ使用长轮询，同push方式实时性一致，消息的投递延时通常在几个毫秒。
### 消费失败重试
* Kafka消费失败不支持重试；
* rocketMQ消费失败支持定时重试，每次重试将时间顺延。
> 例如充值类应用，当前时刻调用运营商网关，充值失败，可能是对方压力过多，稍后再调用就会成功，如支付宝到银行卡扣款也是类似需求。此处的重试需要可靠的重试，即失败重试的消息不因为consumer宕机导致丢失。
### 严格的消息顺序
* Kafka支持消息顺序，但是一台代理宕机后，会产生消息乱序；
* rocketMQ支持严格的消息顺序，在顺序消息场景下，一台broker宕机后，发送消息会失败，但是不会乱序。
> MySQL的二进制日志分发需要严格的消息顺序。
### 定时消息
* Kafka不支持定时消息；
* rocketMQ支持两类定时消息；
* 开源版本rocketMQ仅支持定时级别，定时级用户可定制；
* 阿里云MQ指定的毫秒级别的。
### 分布式事务消息
* Kafka不支持分布式事务消息；
* 阿里云MQ支持分布式事务消息，部分开源版本也支持（3.0.8之前以及4.3.0之后）。
### 消息查询
* Kafka不支持消息查询；
* rocketMQ支持根据消息标识查询，也支持消息内容查询（发送消息指定一个消息密钥）。
> 消息查询对于定位消息丢失等问题很有帮助。
### 消息回溯
* Kafka理论上可以按照offset来回溯消息；
* rocketMQ支持按照时间来回溯消息，精度毫秒，如从一天之前的某时某分某秒开始重新消费消息。
### 消息并行度
* Kafka消费并行度依赖topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开始1个线程），或者1台机器消费（10个线程并行消费），即消费并行度和分区数一致；
* rocketMQ消费并行度，①：顺序消费并行度与Kafka一致；②：乱序方式并行度取决于consumer线程数，如topic配置10个队列，10台机器消费，每台机器100个线程，则并行度为1000.
### 消息轨迹
* Kafka不支持消息轨迹；
* 阿里云MQ支持消息轨迹。