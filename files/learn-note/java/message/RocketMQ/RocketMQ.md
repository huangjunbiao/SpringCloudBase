# RocketMQ
阿里巴巴开源产品，Java实现，参考了Kafka并改进。单机吞吐量10万级，可用性非常高，分布式架构，消息可做到0丢失，功能较为完善，扩展性好，支持10亿级别的消息堆积。
## 基本概念
核心四大组件：Name Server、Broker、Producer、Consumer，每个组件都可以部署成集群模式进行水平扩展。
### 生产者
生产者（Producer）负责产生消息，生产者向消息服务器发送由业务应用系统生成的消息。RocketMQ提供了三种方式发送消息：同步、异步和单向。
#### 同步发送
同步发送指消息发送方发出数据后会在收到接受方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。
#### 异步发送
异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。
#### 单向发送
单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求不高的场景，例如日志收集。
#### 生产者组
生产者组（Producer Group）是一类Producer的集合，这类Producer通常发送一类消息并且发送逻辑一致，所以将这些Producer分组在一起。从部署结构上看生产者通过Producer Group的名字来标记自己是一个集群。
### 消费者
消费者负责消费消息，消费者从消息服务器拉去信息并将其输入用户应用程序。站在用户应用的角度消费者有两种类型：拉取型消费者、推送型消费者。
#### 拉取型消费者
Pull Consumer主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以pull称为主动消费型。  
消费端一定的频率主动发起拉消息请求，获得服务端消息响应，再按照相同的频率发起拉消息请求。并不推荐这种模式是因为需要处理好拉取频率否则容易导致消息堆积和消息空缺的问题。
#### 推送型消费者
Push Consumer封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以称push为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于pull的是push首先要注册消费监听器，当然监听器触发后才开始消费消息。  
消息到达消息服务器后，推送消息给消费者。推模式并不是真正意义上的服务端将消息推送给消费端。本质实现为消费端消息拉取线程在从服务器拉取到一批消息后，
然后提交到消息消费线程池后，又继续向服务器再次尝试拉取消息，再提交到消息消费线程池，然后由消费端消费线程异步的从消费线程池获取消息进行消息消费，
解耦了消息拉取和消息消费过程。若未拉取到消息，则延迟一下又继续拉取。
pull+长轮询，长轮询默认15s，通过长轮询达到了push的实时性又有了pull的可控性。
#### 消费者组
Consumer Group 一类Consumer的集合名称，这类Consumer通常消费同一类消息并且消费逻辑一致，所以将这些Consumer分组在一起。
消费者组于生产者组类似，都是将相同角色的分组在一起并命名，rocketMQ通过分组机制实现天然的消息负载均衡。
消费消息时通过消费者组实现将消息分发到多个消费者服务器实例。
### 消息服务器
Broker是消息存储中心，主要作用是接收来自Producer的消息并存储，Consumer从这里取得消息。它还存储于消息相关的元数据，
包括用户组、消费进度偏移量、队列信息等。从部署结构可以看出Broker有Master和Slave两种类型，Master既可以写又可以读，Slave不可以写只可以读。
从物理结构上看集群部署方式有：单Master、多Master、多Master多Slave（同步刷盘）、多Master多Slave（异步刷盘）。
#### 单Master
一旦Broker重启或宕机会导致整个服务不可用。
#### 多Master
所有消息服务器都是Master，没有Slave。配置简单，单个Master宕机或重启维护对应用无影响，缺点是单台机器宕机时该机器上未被消费的消息在机器恢复之前不可订阅，
消息实时性会受影响。
#### 多Master多Slave（异步复制）
每个Master配置一个Slave，所以有多对Master-Slave，消息采用异步复制方式，主备之间有毫秒级消息延迟。
优点是消息丢失的非常少，且消息实时性不会受影响，Master宕机后消费者可以继续从Slave消费，中间的过程透明，性能同多Master几乎一样。缺点是Master宕机时在磁盘损坏情况下会丢失少量消息。
#### 多Master多Slave（同步双写）
每个Master配置一个Slave，所以有多对Master-Slave，消息采用同步双写方式，主备都写成功才返回成功。
优点是数据于服务都没有单点问题，Master宕机时消息无延迟，服务与数据的可用性非常高。缺点是性能相对异步复制略低，发送消息的延迟会略高。
### 名称服务器
NameServer用来保存Broker相关元信息并给Producer和Consumer查找broker信息。NameServer被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标识自己是一个伪集群。
每个Broker在启动时候会到NameServer注册，Producer在发送消息前会根据topic到NameServer获取到Broker的路由信息，Consumer也会定时获取到topic的路由信息。
从功能上看和zookeeper差不多。

### 消息
消息（Message）即传输的信息。一条消息必须有一个主题（topic），主题可以看做是信件要邮寄的地址。一条消息可以拥有一个可选的标签（tag）和额外的键值对，它们可以用于设置一个业务key并在Broker上查找此消息以便在开发期间寻找问题。
### 主题
topic可以看作消息的规类，它是消息的第一级类型，一条消息必须有一个topic。
topic于生产者和消费者关系非常松散，一个topic0个或多个生产者向其发送消息，一个生产者也可以同时向不同的topic发送消息。一个topic也可以被0个或多个消费者订阅。
### 标签
tag可以看作是子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息可以用相同topic而不同的tag来标识。
比如交易消息可以分为：交易创建消息、交易完成消息等，一条消息可以没有tag。
### 消息队列
Message Queue，主题被划分为一个或多个子主题，即消息队列。一个topic下可以设置多个消息队列，发送消息时执行该消息的topic，rocketMQ会轮询该topic下的所有队列将消息发出去。
### 消息消费模式
集群消费（Clustering）和广播消费（Broadcasting）。默认情况下为集群消费，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其他消费者会接替挂掉的消费者继续消费。
而广播消费消息会发给消费者组中的每一个消费者进行消费。
#### 广播模式
主题下的同一条消息被集群内所有消费者消费一次。即使多个Consumer属于同一个ConsumerGroup，每个Consumer也会消费一次。
#### 集群模式
主题下的同一条消息只允许被其中一个消费者消费。一个消费者组内可以包含多个消费者，一个消费者组订阅相同的消息主题，一个主题topic拥有多个消息存储队列。
每一个组内的消费者可以消费这个topic下的多个消息队列，topic下的一个消息队列只能被同一个组的一个消费者消费（一条消息只会被同Group中的一个Consumer消费，多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据）。
### 消息顺序
Message Order有两种：顺序消费（Orderly）和并行消费（Concurrently）。顺序消费表示消费的顺序同生产者为每个消息队列发送的消息一致，所以如果正在处理全局顺序是强制性的场景，需要确保使用的主题只有一个消息队列。
并行消费不再保证消息顺序，消费的最大并行数量受每个消费者客户端指定的线程池限制。
#### 顺序消息
消息消费的顺序和生产者发送消息的顺序一致。
* 分区有序  
分区有序是指这个topic下这个队列下的消息是有顺序的，生产者发送消息的时候，将严格按照消息的顺序，将消息们发送到一个topic下的一个队列，从而保证了生产者分区消息有序，消费者进行消费时，进行单线程单队列消费，保证消息有序。
适用于性能要求高，以sharding key作为分区字段，在同一个队列中严格的按照FIFO原则进行消息发布和消费的场景。如订单。
* 全局有序
是指某个topic下的所有消息都要保证顺序，可以通过一个topic只有一个消息队列，保证了全局有序，实际是分区有序变种。
适用于性能要求不高，所有的消息严格按照FIFO原则进行消息发布和消费的场景。

### 消息队列如何保证不丢失消息
主要三个阶段：生产者保证不丢消息、存储端保证不丢消息、消费者不丢消息
#### 生产者不丢消息
Produce生产者提供了三种发送消息的方式：同步发送、异步发送、单向发送。若想要发消息不丢失：
* 采用同步方式发送，send消息方法返回成功状态，就表示消息正常到达存储端Broker；
* 如果send消息异常或返回非成功状态，可以重试；
* 如果使用事务消息，rocketMQ的事务消息机制就是为了保证零丢失设计的。
> 为了减小丢失消息的可能性尽量采用同步的发送方式，同步等待发送结果，利用同步发送+重试机制+多master节点减少消息丢失。
#### 存储端不丢失消息
确保消息持久化到磁盘，即刷盘机制：同步刷盘和异步刷盘。【通过同步刷盘策略+同步slave策略+主从的方式解决丢失消息的可能】
* 生产者消息发送过来，只有持久化到磁盘，rocketMQ的存储端才返回一个成功的ACK响应，这就是同步刷盘，保证消息不丢失，但是影响了性能；
* 异步刷盘：只要消息写入PageCache缓存，就返回一个成功ACK响应，这样提高了MQ的性能，但是如果这时候机器断电了，就会丢失消息。
> broker一般是集群部署的，由master节点和salve从节点。消息到Broker存储端，只有主节点和从节点都写入成功，才反馈成功的ack给生产者。这就是同步复制，保证了消息不丢失，但是降低了系统的吞吐量。与之对应的异步复制，只要消息写入主节点成功，就返回成功的ack，这样速度快，但正确性有影响。
#### 消费阶段不丢失消息
消费者执行完业务逻辑再反馈Broker消费成功，这样就可以保证消费阶段不丢失消息。【通过At least Once+消费重试机制保证】
> rocketMQ默认提供了at least once机制保证消息可靠消费，即consumer先pull消息到本地，消费完成后，才向服务器返回ack。
### 重复消费
一般是生产者发送来的一条消息，消费者在处理消息时异常且没有被捕获，会导致消息被放到了重试队列进行重试。引起消息重试两种情况：内部异常和消费超时。  
解决重复消费主要是消费端业务开发消费消息时保证幂等性，使用业务唯一标识主键来处理逻辑。

### mmap
RocketMQ使用mmap来提升吞吐量（CPU拷贝）
#### 什么是mmap
mmap系统调用，让用户地址空间，跟文件做映射（实际是指向不存在的物理内存）。将内核态的一段空间地址映射到用户态中，这样数据只需要写入到用户态的这段虚拟地址中，接着内核空间的DMA会将这段数据写入到磁盘中。以此可以减少一次CPU拷贝次数提升性能。
> 其实DMA本质上是一块访问独立的芯片。由于每次访问磁盘进行IO操作都会导致CPU大量的空闲时间，而DMA则是用于提升IO操作效率的角色，主要用于IO的数据传输，降低CPU等待时间。
#### mmap缺陷
* 导致缺页中断问题
* mmap对于文件的大小有一定要求
#### RocketMQ对mmap的优化
* 预映射：AllocateMappedFileService该类负责在mq启动时预先分配mmap的文件映射；
* 文件预热：进行madvise系统调用，目的是使操作系统做一次内存映射后对应的文件数据尽可能多的预加载进内容，从而实现预热；
* 内存锁定：将进程使用的部分或者全部的地址空间锁定在物理内存中，并会先写入一些随机值到mmap映射出的内存空间里防止其被交换到swap空间。基于mlock系统调用；
* 堆外缓存：RocketMQ底层增加了一套堆外缓存来优化这类场景。当PageCache写入阻塞的时候，可以选择写入到堆外缓存中，之后再从堆外缓存  (DirectByteBuffer) 写入到PageCache。

