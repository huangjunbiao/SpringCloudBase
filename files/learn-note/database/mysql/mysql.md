# MySQL
是一种关系型数据库，是开源免费的，并且方便扩展。
## 存储引擎
5.5版本之前，MyISAM是MySQL的默认数据库引擎，5.5之后默认引擎是InnoDB.
## 存储原理
### 数据页
一般使用MySQLD都会将数据持久化到磁盘，而不是内存，从而保证数据不丢失和容量。  
4K对齐，读磁盘当中数据时可能值读很少的数据几个字节，但真正从磁盘当中读出的数据至少要有4K，无论是否用到都会存储到内容空间，此后再读相关数据可以节省时间。  
在MySQL数据库中对于InnoDB存储引擎，存储的基本单位就是数据页，默认要有16KB大小。
### 行格式
COMPACT行格式有一个字段叫NULL标志位，用来记录这一行中哪些字段为空。也就是说一行数据，真正的大小是大于一行中数据所占的大小，会有额外字段占用空间。varchar可变字节，也需要额外空间存储长度。  
通过分页存储大段数据，每页存储一部分数据以及下一页地址。
### 页目录
对于InnoDB 存储引擎，插入的数据会被自动排序。对于线性表来说，随即插入操作时间复杂度为O(n)，InnoDB 存储引擎采用顺序线性表来存储我们的数据，那么就很容易造成数据插入效率低下的为问题。所以实际上，行与行之间采用链表方式相连。  
为了减少查询花费时间，页中有一部分存储空间，叫页目录，存储在页中的数据会被分组，其中，用一个页目录来专门存放每组的起始id。
### 聚集索引
分页的数据需要一个结构能把所有页找到，类似于页目录，需要额外一个页（目录页），存储页信息。以此，先通过目录页找到记录所在的那一页，再通过页中的目录找到数据所在那一组，最后从组开始遍历数据找到该条。  
InnoDB 底层采用的是 b+ 树，必须有主键，所以一定会有主键索引，也叫聚簇索引、聚集索引，即所有的数据都存储在叶子节点中。当新增一个页时，会将起始页复制出一个，然后将原先的起始页修改成新的目录页。  
目录页、页目录都不存储行里的所有记录，只包含一个id索引和目标地址的指针。这样索引目录的数量会比较少，树的层数、高度会低，可以减少磁盘IO带来的开销。
### 非主键索引
不存储行数据，只存储主键的值。即查找到了主键，但不能直接获得其他列数据，还必须通过id回到主键索引，去查取整个行记录。  
覆盖索引的查询优势：查询的字段，就已经是非主键索引的排序字段了，我们在这棵索引树上可以直接获取到字段的值，而不用去回表扫描，增大 I/O 的开销。
### MySQL存储引擎InnoDB与MyISAM
* InnoDB支持外键，MyISAM不支持；
* InnoDB支持MVCC（多版本并发控制），MyISAM不支持；
* select count(*)MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB需要全表扫描；
* InnoDB不支持全文索引，MyISAM支持（InnoDB5.7之后支持）；
* InnoDB支持表、行级锁，MyISAM支持表级锁；
* InnoDB表必须有主键，MyISAM可以没有主键；
* InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小；
* InnoDB按主键大小有序插入，MyISAM按记录插入顺序保存；
* InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与MyISAM比InnoDB写效率差一些，并且会占用更多的磁盘空间以保留数据和索引。
## 索引
MySQL索引使用的数据结构主要有BTree索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。  
MySQL的BTree索引使用的是B树中的B+Tree，对于两种存储引擎实现方式不同。
* MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为非聚簇索引。
* InnoDB：其数据文件本身就是索引文件。其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为聚簇索引。其余索引都作为辅助索引，辅助索引的娃娃data域存储相应记录主键的值而不是地址。在根据祝主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
## 事务
### 并发事务的问题
* 脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问到了该数据，然后使用了该数据。因为这个数据还没有提交，所以另外一个事务读到的是脏数据；
* 丢失修改：一个事务读取一个数据时，另外一个事务也访问了该数据，那么第一个事务中修改了这个数据后，第二个事务也修改了数据，则第一个事务中修改数据的结果被丢失。
* 不可重复读：在一个事务内多次读取同一个数据，这个事务还没有结束时，另一个事务也访问该数据。那么第一个数据的两次读取数据之间，由于第二个事务的修改可能会导致第一个事务两次读取数据不一样。
* 幻读：一个事务读取了几行数据，另一个并发事务插入了一条数据，在之后的查询中第一个事务会发现多了一个不存在的记录，如同幻觉。
### 事务隔离级别
InnoDB默认支持的隔离级别是可重复读。
* 读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读。
* 读已提交：允许读取并发事务已提交的数据，可以阻止脏读，仍存在幻读、不可重复读；
* 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。可以阻止脏读、不可重复读，但仍存在幻读；
* 可串行化：最高的隔离级别，完全服从ACID的隔离级别，所有事务依次执行，事务之间不会产生干扰，可以防止脏读、幻读、不可重复读。

### binlog日志
binlog是归档日志，属于MySQL server层的日志。可以实现主从复制和数据恢复两个作用。当需要数据恢复时，可以取出某个时间范围内的binlog进行重放恢复即可。
#### binlog日志格式
statement
* statement格式，binlog记录的是SQL原文，它可能会导致主库不一致（主库和从库选的索引不一样时）。假设主库执行删除的SQL（其中 a 和 create_time 都有索引）【delete from t where a > '666' and create_time<'2022-03-01' limit 1;】。数据选择了a索引和选择create_time索引，最后limit 1出来的数据一般不一样。所以就会存在：在binlog=statement格式时主库在执行这条SQL使用的是a索引，而从库在执行这条SQL时使用了B索引，最后主从数据不一致了。

row
* row格式可以解决上述问题，row格式binlog记录的不是SQL原文，而是两个event:Table_map和Delete_rows。Table_map event说明要操作的表，Delete_rows event说明要删除的行为，记录删除的具体行数。row格式binlog记录的就是要删除的主键ID信息，因此不会出现主从不一致的问题。但是如果SQL删除10万行数据，使用row格式会很占空间，写binlog也很耗IO。

mixed
* mixed格式可以解决上述问题。其实就是row和statement格式混合使用，当MySQL判断可能数据不一致时，就用row格式，否则就是用statement格式。