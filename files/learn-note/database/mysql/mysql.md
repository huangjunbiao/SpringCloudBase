# MySQL
是一种关系型数据库，是开源免费的，并且方便扩展。
## 存储引擎
5.5版本之前，MyISAM是MySQL的默认数据库引擎，5.5之后默认引擎是InnoDB.
### MySQL存储引擎InnoDB与MyISAM
* InnoDB支持外键，MyISAM不支持；
* InnoDB支持MVCC（多版本并发控制），MyISAM不支持；
* select count(*)MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB需要全表扫描；
* InnoDB不支持全文索引，MyISAM支持（InnoDB5.7之后支持）；
* InnoDB支持表、行级锁，MyISAM支持表级锁；
* InnoDB表必须有主键，MyISAM可以没有主键；
* InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小；
* InnoDB按主键大小有序插入，MyISAM按记录插入顺序保存；
* InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与MyISAM比InnoDB写效率差一些，并且会占用更多的磁盘空间以保留数据和索引。
## 索引
MySQL索引使用的数据结构主要有BTree索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。  
MySQL的BTree索引使用的是B树中的B+Tree，对于两种存储引擎实现方式不同。
* MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为非聚簇索引。
* InnoDB：其数据文件本身就是索引文件。其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为聚簇索引。其余索引都作为辅助索引，辅助索引的娃娃data域存储相应记录主键的值而不是地址。在根据祝主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
## 事务
### 并发事务的问题
* 脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问到了该数据，然后使用了该数据。因为这个数据还没有提交，所以另外一个事务读到的是脏数据；
* 丢失修改：一个事务读取一个数据时，另外一个事务也访问了该数据，那么第一个事务中修改了这个数据后，第二个事务也修改了数据，则第一个事务中修改数据的结果被丢失。
* 不可重复读：在一个事务内多次读取同一个数据，这个事务还没有结束时，另一个事务也访问该数据。那么第一个数据的两次读取数据之间，由于第二个事务的修改可能会导致第一个事务两次读取数据不一样。
* 幻读：一个事务读取了几行数据，另一个并发事务插入了一条数据，在之后的查询中第一个事务会发现多了一个不存在的记录，如同幻觉。
### 事务隔离级别
InnoDB默认支持的隔离级别是可重复读。
* 读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读。
* 读已提交：允许读取并发事务已提交的数据，可以阻止脏读，仍存在幻读、不可重复读；
* 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。可以阻止脏读、不可重复读，但仍存在幻读；
* 可串行化：最高的隔离级别，完全服从ACID的隔离级别，所有事务依次执行，事务之间不会产生干扰，可以防止脏读、幻读、不可重复读。



### binlog日志
binlog是归档日志，属于MySQL server层的日志。可以实现主从复制和数据恢复两个作用。当需要数据恢复时，可以取出某个时间范围内的binlog进行重放恢复即可。
#### binlog日志格式
statement
* statement格式，binlog记录的是SQL原文，它可能会导致主库不一致（主库和从库选的索引不一样时）。假设主库执行删除的SQL（其中 a 和 create_time 都有索引）【delete from t where a > '666' and create_time<'2022-03-01' limit 1;】。数据选择了a索引和选择create_time索引，最后limit 1出来的数据一般不一样。所以就会存在：在binlog=statement格式时主库在执行这条SQL使用的是a索引，而从库在执行这条SQL时使用了B索引，最后主从数据不一致了。

row
* row格式可以解决上述问题，row格式binlog记录的不是SQL原文，而是两个event:Table_map和Delete_rows。Table_map event说明要操作的表，Delete_rows event说明要删除的行为，记录删除的具体行数。row格式binlog记录的就是要删除的主键ID信息，因此不会出现主从不一致的问题。但是如果SQL删除10万行数据，使用row格式会很占空间，写binlog也很耗IO。

mixed
* mixed格式可以解决上述问题。其实就是row和statement格式混合使用，当MySQL判断可能数据不一致时，就用row格式，否则就是用statement格式。